#+title: introduction to lattices and order

* 1 ordered sets

*** terms

    - (order) (partial order)
      reflexivity, antisymmetry and transitivity

      A set P equipped with an order relation
      is said to be an ordered set
      (or partially ordered set) (or poset)

    - (discrete order)
      on any set, == is an order

    - (quasi-order) (pre-order)
      reflexivity and transitivity

    - (strict inequality)
      x <= y and x != y

    - (comparable)
      x <= y or x >= y

    - (incomparable)
      not x <= y and not x >= y

    - (induced order)
      the order that subset inherited from superset

    - (chain) (linearly ordered set) (totally ordered set)
      either x <= y or x >= y

    - (antichain)
      x <= y then x == y

      when using the term chain and antichain, we are often considering subsets

      A chain is a subset in which each pair of elements is comparable;
      that is, C is totally ordered.

      An antichain is a subset in which each pair of different elements is incomparable;
      that is, there is no order relation between any two different elements.

    - (order-isomorphism)
      necessarily bijective
      using reflexivity and antisymmetry
      f(x) == f(y)
      <=> f(x) <= f(y) and f(x) =< f(y)
      <=> x <= y and x =< y
      <=> x == y

*** informative

    - for data, >= can be defined as
      "is at least as informative as"

*** programs

    - The term state is used to denote an assignment,
      to the variables used by a program,
      of values drawn from the appropriate datatypes.

      The program terminates if it transforms any given state
      before its execution to a state afterwards;
      the initial and final states may be regarded as
      incorporating the input and output data.

      Frequently, the result of a computation
      will be generated step by step,
      with additional information being gained at each stage.

    - Non-termination of a program naturally arises where
      only partial information towards the solution is output in finite time.

      A program is deterministic if, starting from a given initial state,
      it will terminate in the same final state each time it is run.

      Non-determinism can occur where the programâ€™s specification
      allows for more than one valid solution.

*** partial maps

    - f, g: PartialMap(A, B)
      f <= g
      :== dom(f) <= dom(g)
      and forall x: dom(f) => f(x) == g(x)

    - function of type A => B might be viewed as
      been built up from elements of PartialMap(A, B)

    - two partial maps are consistent if we can merge them.

      if f and g are consistent,
      but f does not terminate for some input where g does,
      we can run both f and g in parallel, and kill f when g terminates.

      if f and g are consistent,
      but f runs slower for some input where g runs faster,
      we can run both f and g in parallel, and kill f when g terminates.

      in these cases, we say g refines f.

    - refinement of PartialMap is commutative, associative, and idempotent.

*** semantics and semantic domains

    - a semantic domain is a mathematical structure
      through which one can describe, analyse and reason about
      the behaviour of entities such as datatypes, programs and specifications.

* 2 lattices and complete lattices

* 3 formal concept analysis
